<!DOCTYPE html>
<html>
<head>
    <title>Starting</title>
    <link rel="stylesheet" href="sandboxDemo.css">
<!-- Load the Paper.js library -->
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script>
<!-- Define inlined PaperScript associate it with myCanvas -->
<script type="text/paperscript" canvas="myCanvas">
// Colors
var red_color = "#ff3657";
var green_color = "#8dff36";
var black_color = "#242424";
var black_color_h = "#575757";
var grid_dot_color = "#000000"; // Color for grid dots

// Grid size
var gridSize = 20; // Change this value to adjust the grid cell size
var gridDotRadius = 1; // Radius of the grid dots

// Grid dimensions (fixed size)
var gridWidth = 500; // Width of the grid
var gridHeight = 500; // Height of the grid

// Calculate center position
var centerX = view.size.width / 2;
var centerY = view.size.height / 2;

// Create layers
var backgroundLayer = new Layer(); // Layer for grid dots
var foregroundLayer = new Layer(); // Default layer for other elements
var textLayer = new Layer(); // Layer for the plus symbols

// Initial circles
var Z_spi_init = new Path.Circle({
    center: [centerX - 0, centerY - 0], // Adjust initial position as needed
    radius: 8,
    strokeColor: black_color,
    strokeWidth: 2,
    fillColor: green_color,
    parent: foregroundLayer // Add to the foreground layer
});

var X_spi_init = new Path.Circle({
    center: [centerX - 0, centerY + 0], // Adjust initial position as needed
    radius: 8,
    strokeColor: black_color,
    strokeWidth: 2,
    fillColor: red_color,
    parent: foregroundLayer // Add to the foreground layer
});
// Cable box
var string_rect = new Path.Rectangle({
    point: [centerX - 290, centerY + 50], // Top-left corner
    size: [25, 25], // Width and height
    strokeColor: black_color, // Black border
    strokeWidth: 1, // Border width
    fillColor: 'white', // Completely transparent fill
    parent: foregroundLayer,
        });
string_rect.smooth({ type: 'geometric', factor: 0.05 });
// Change cursor to hand when hovering over the rectangle
string_rect.onMouseEnter = function(event) {
    document.getElementById('myCanvas').style.cursor = 'pointer';
    spline.visible = true;
};
// Revert cursor when not hovering
string_rect.onMouseLeave = function(event) {
    if (drawingActive) {
        document.getElementById('myCanvas').style.cursor = 'crosshair';
    } else {
        document.getElementById('myCanvas').style.cursor = 'default';
    }
    spline.visible = false;

};
    
string_rect.onClick = function(event) {
    drawingActive = !drawingActive
}

// Plus symbols
var Z_spi_plus = new PointText({
    point: Z_spi_init.position,
    content: '+',
    fillColor: black_color,
    fontSize: 15,
    fontFamily: 'Arial',
    parent: textLayer // Add to the text layer
});
Z_spi_plus.visible = false; // Initially hidden

var X_spi_plus = new PointText({
    point: X_spi_init.position,
    content: '+',
    fillColor: black_color,
    fontSize: 15,
    fontFamily: 'Arial',
    parent: textLayer // Add to the text layer
});
X_spi_plus.visible = false; // Initially hidden

// Create string icon
var spline = new Path({
    strokeColor: 'black',
    strokeWidth: 1,
    parent: textLayer
});
// 4 points to the path
spline.add(new Point(string_rect.position.x - 20, string_rect.position.y - 20));
spline.add(new Point(string_rect.position.x - 10, string_rect.position.y - 17));
spline.add(new Point(string_rect.position.x - 15, string_rect.position.y - 11));
spline.add(new Point(string_rect.position.x - 5, string_rect.position.y - 5));
spline.smooth();
spline.visible = false;
spline.fullySelected = false; // Prevent it from being selected
spline.guide = true; // Make it a non-interactive guide path (optional)
spline.ignoreEvents = true; // Disable hit testing for this path

var spiders = [];
var strings = [];
var spi_cen_pos = []; // position from centre for resizing
var active_spi = null;
var activePath = null;
var Z_spi_selected = false;
var X_spi_selected = false;
var drawingActive = false;

// Create grid dots
function createGridDots() {
    backgroundLayer.removeChildren(); // Clear existing grid dots
    
    var startX = centerX - gridWidth / 2;
    var startY = centerY - gridHeight / 2;

    for (var x = startX; x < startX + gridWidth; x += gridSize) {
        for (var y = startY; y < startY + gridHeight; y += gridSize) {
            new Path.Circle({
                center: [x, y],
                radius: gridDotRadius,
                fillColor: grid_dot_color,
                parent: backgroundLayer // Add to the background layer
            });
        }
    }
}

function onResize(event) {
    // Recalculate center position
    centerX = view.size.width / 2;
    centerY = view.size.height / 2;

    // Center initial spiders
    Z_spi_init.position = [centerX - 290, centerY - 30];
    X_spi_init.position = [centerX - 290, centerY + 10];
    string_rect.position = [centerX - 290, centerY + 50];
    spline.position = [centerX - 290, centerY + 50];
    
    // Update plus symbols position
    Z_spi_plus.position = Z_spi_init.position;
    X_spi_plus.position = X_spi_init.position;
    
    // Recreate grid dots
    createGridDots();
    
    // centre placed spiders
    for (var i = 0; i < spi_cen_pos.length; i++) {
        // var pos_ = spi_cen_pos[i];
        console.log(spi_cen_pos[i])
        spiders[i].position = spi_cen_pos[i] + view.center
        }
}

function onMouseDown(event) {
    // Check if any existing circle is clicked
    for (var i = 0; i < spiders.length; i++) {
        var circle = spiders[i];
        if (circle.contains(event.point)) {
            // Start dragging the clicked circle
            active_spi = circle;
            active_spi.dragging = true;
            active_spi.lastPoint = event.point; // Store the last point
            return;
        }
    }

    // If the green initial circle is clicked, create a new circle
    if (Z_spi_init.contains(event.point)) {
        active_spi = new Path.Circle({
            center: snapToGrid(event.point),
            radius: 8,
            strokeColor: black_color,
            strokeWidth: 2,
            fillColor: green_color,
            parent: foregroundLayer // Add to the foreground layer
        });
        spiders.push(active_spi); // Add the new circle to the array
        spi_cen_pos.push(active_spi.position - view.center)
        active_spi.dragging = true;
    }

    // If the red initial circle is clicked, create a new circle
    else if (X_spi_init.contains(event.point)) {
        active_spi = new Path.Circle({
            center: snapToGrid(event.point),
            radius: 8,
            strokeColor: black_color,
            strokeWidth: 2,
            fillColor: red_color,
            parent: foregroundLayer // Add to the foreground layer
        });
        spiders.push(active_spi); // Add the new circle to the array
        spi_cen_pos.push(active_spi.position - view.center)
        active_spi.dragging = true;
    }
    else {
        // If clicking elsewhere and there's an active circle, stop dragging
        if (active_spi) {
            active_spi.dragging = false;
            active_spi = null;
        }
    }
}

function onMouseDrag(event) {
    // If an active circle is being dragged, move it to the snapped cursor position
    if (active_spi && active_spi.dragging) {
        // Snap the cursor position to the grid
        var snappedPoint = snapToGrid(event.point+[10,10]);
        active_spi.position = snappedPoint;
        for (var i = 0; i < spi_cen_pos.length; i++) {
            spi_cen_pos[i] = spiders[i].position - view.center // update centred
        
        }
    }
}

view.onClick = function(event) {
    var hitResult = project.hitTest(event.point); // ensure pen does not activate ontop of another object
    if (drawingActive && !activePath && !hitResult) {
        // Create a new path and add the initial point, snapped to the grid
        activePath = new Path({
            strokeColor: black_color,
            strokeWidth: 1
        });
        activePath.add(snapToGrid(event.point+[10,10]));
    } else if (drawingActive && activePath) { // If drawing is active, add the final point, snapped to the grid, and stop drawing
        activePath.add(snapToGrid(event.point+[10,10]));
        activePath.simplify();
        activePath.smooth(); // Smooth to create a spline effect
        strings.push(activePath)
        drawingActive = false;
        activePath = null;
        document.getElementById('myCanvas').style.cursor = 'default';
    }
}
    

function onMouseUp(event) {
    // Stop dragging when the mouse button is released
    if (active_spi) {
        active_spi.dragging = false;
        active_spi = null;
    }
}

function onMouseMove(event) {
    // Check if the mouse is over the green initial circle
    if (Z_spi_init.contains(event.point)) {
        if (!Z_spi_selected) {
            Z_spi_init.strokeColor = black_color_h;
            Z_spi_init.strokeWidth = 3;
            Z_spi_plus.visible = true; // Show the plus symbol
            Z_spi_selected = true;
        }
    } else {
        if (Z_spi_selected) {
            Z_spi_init.strokeColor = black_color;
            Z_spi_init.strokeWidth = 2;
            Z_spi_plus.visible = false; // Hide the plus symbol
            Z_spi_selected = false;
        }
    }

    // Check if the mouse is over the red initial circle
    if (X_spi_init.contains(event.point)) {
        if (!X_spi_selected) {
            X_spi_init.strokeColor = black_color_h;
            X_spi_init.strokeWidth = 3;
            X_spi_plus.visible = true; // Show the plus symbol
            X_spi_selected = true;
        }
    } else {
        if (X_spi_selected) {
            X_spi_init.strokeColor = black_color;
            X_spi_init.strokeWidth = 2;
            X_spi_plus.visible = false; // Hide the plus symbol
            X_spi_selected = false;
        }
    }
    if (drawingActive && activePath) {
        activePath.add(event.point);
    }
}

// Function to snap a point to the nearest grid intersection
function snapToGrid(point) {
    return new Point(
        Math.round((point.x-view.center.x)/ gridSize ) * gridSize + view.center.x - 10,
        Math.round((point.y-view.center.y)/ gridSize) * gridSize + view.center.y - 10
    );
}

// Setup event listeners
view.on('mousedown', onMouseDown);
view.on('mousemove', onMouseMove);
view.on('mousedrag', onMouseDrag);
view.on('mouseup', onMouseUp);

// Initial setup
createGridDots();



</script>
</head>
<body>
    
    <canvas id="myCanvas" resize></canvas>
    
</body>
</html>
